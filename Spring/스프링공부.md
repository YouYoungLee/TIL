# RestController
- Controller에 ResponseBody가 추가된 것입니다. 주용도는 Json 형태로 객체 데이터를 반환하는 것입니다. 최근에 데이터를 응답으로 제공하는 REST API를 개발할 때 주로 사용하며 객체를 ResponseEntity로 감싸서 반환합니다.
# RequiredArgsConstructor
- final이 붙거나 @NotNull이 붙은 필드의 생성자를 자동 생성해주는 롬복 어노테이션
# final
- final은 무언가를 제한하겠다는 의미
- final은 재할당을 제한함 - 메모리의 재할당, 즉 값은 변할 수 있음
- 상수의 경우 재할당을 하지 못하면, 초기화값이 불변하기 때문에 값이 불변
# static
- static은 값을 static(정적) 메모리 영역에 올리겠다는 선언
- 즉, 어디에서 호출해도, 모든 곳에서 데이터를 공유함 - 정적메모리 영역에 올려져있어 전역적으로 사용이 가능
# private final(생성자 주입 : Constructor Injection)
- 생성자 기반 DI
# @Autowired 
- 필드에 자동으로 의존성이 주입됩니다
# setter
- 수정자 주입
# ResponseEntity
- Spring Framework에서 제공하는 클래스 중 HttpEntity라는 클래스가 존재한다. 이것은 HTTP 요청(Request) 또는 응답(Response)에 해당하는 HttpHeader와 HttpBody를 포함하는 클래스이다.
# NoArgsConstructor
- 파라미터가 없는 기본 생성자를 생성
# AllArgsConstructor
- 모든 필드 값을 파라미터로 받는 생성자를 만듦
# Service를 Interface로 생성 하는 이유
1. OOP(객체지향프로그래밍)의 인터페이스와 Loose Coupling
- Interface는 객체의 사용 방법을 정의한 타입이다. 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다. 즉, 개발 코드를 수정하지 않고 사용하는 객체를 변경할 수 있도록 해준다.
2. AOP
- AOP와 트랜잭션은 서비스 인터페이스에서 처리한다. 스프링에서 AOP를 구현할 때 JDK의 기본 프록시를 사용하는데, 이 프록시는 인터페이스 기반으로 동작하기 때문에 Service 인터페이스를 만들어 사용한다.
# JPA Repository
- 핵심은 ImportBeanDefinitionRegistrar인터페이스
1. SpringFrameWork의 인터페이스이며 구현체가 다양함
2. 빈을 프로그래밍을 통해서 등록할 수 있게 해줌
3. JpaRepository를 상속받은 모든 인터페이스들을 찾아서 빈으로 등록해줌
- 개별 interface를 만들고 JpaRepository라는 interface를 상속받음
- JpaRepository 첫번째 타입은 Entity 타입이고 두번째 타입은 Entity에서 사용하는 PK_Type
- @EnableJpaRepositories는 스프링부트가 자동 설정해줌
- 생산성,유지보수성,코드의 간결함, 간결한 코드로 인해 테스트 작성이 불필요함
# 의존이란?
- DI란 Dependency Injection의 약자로 의존 주입이라고 한다 의존이란 객체 간의 의존을 의미한다. 즉, 한 클래스가 다른 클래스의 메서드를 실행할 때, 이를 '의존'한다고 표현한다
- 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로, 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않도록 하고 런타임 시에 관계를 동적으로 주입하여 유연성을 확보하고 결합도를 낮출 수 있게 해준다.
# 필요한 이유
- 애플리케이션 실행 시점에 필요한 객체(빈)를 생성해야 하며, 의존성이 있는 두 객체를 연결하기 위해 한 객체를 다른 객체로 주입시켜야 하기 때문이다.
# IoC
- Inversion of Control의 줄임말로, 제어의 역전이라는 뜻이 된다. 제어의 역전이란 메소드나 객체의 호출작업을 개발자가 아닌 외부에서 결정되는 것을 의미한다.
# 제네릭(generic)
- 자바에서 제네릭(generic)이란 데이터의 타입(data type)을 일반화한다(generalize)는 것을 의미합니다. 제네릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법
# 장점
1. 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있다
2. 반환값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있다.

# DTO(Data Transfer Objcet) 
- 계층(Layer)간 데이터 교환을 위해 사용하는 객체
- 데이터 교환만을 위해 사용하므로 로직을 갖지 않고, getter/setter 메소드만 갖는다
# VO(Value Objcet)
- 값 그 자체를 표현하는 객체이다
- 로직을 포함할 수 있으며 객체의 불변성(객체의 정보가 변경하지 않음)을 보장한다.
# Entity
- 실제 DB의 테이블과 매핑되는 객체이다 id를 통해 각각의 Entity를 구분한다. VO와 마찬가지로 로직을 가질 수 있다.

# DTO를 VO처럼 포현하면 얻을 수 있는 이점?
- DTO가 전송하고자 하는 데이터가 전송 과정 중에 변조되지 않음을 보장할 수 있다

# 빌더 패턴(Builder Patter)의 장점
1. 필요한 데이터만 설정할 수 있음
2. 유연성을 확보할 수 있음
3. 가독성을 높일 수 있음
4. 변경 가능성을 최소화할 수 있음

# 도메인 객체 중심 개발
- 도메인 모델을 반영하는 객체를 만들어두고, 그것을 중심으로 개발하는 아키텍처를 의미한다.
- 객체를 만들어두고 그 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것이 도메인 객체 중심 아키텍처이다.
1. 객체지향스러운 개발을 할 수 있다.
- 일반적으로 객체는 속성과 기능을 가져야 한다. 그리고 객체들은 단순 속성(데이터)만 갖기 보다는 기능(함수)를 구현함으로써 메세지를 주고 받아야 한다.
2. 도메인 객체의 응집도를 높일 수 있다.
- 기존의 빈약한 객체를 기반으로 한다면 해당 객체와 관련된 비지니스 로직을 파악하기 위해 전체 서비스 레이어를 살펴봐야 한다. 하지만 해당 도메인 객체와 연관된 비지니스 로직을 파악하기 위해서는 해당 객체만 보면 된다.
3. DI를 줄일 수 있다
- 만약 비지니스 로직이 서비스 계층에만 있다면 해당 비즈니스 로직을 갖는 서비스 계층을 DI해야 한다. 하지만 해당 비즈니스 로직이 객체에 있다면 불필요한 DI를 상당히 줄일 수 있다.
4. 서비스 계층의 코드가 간결해진다
- 이러한 방식으로 개발하면 도메인 객체가 스스로 처리가능한 비즈니스 로직을 갖고 있어 서비스 계층의 코드를 간결하게 유지할 수 있다. 그리고 이것은 코드 리딩이나 유지보수성 등을 높여줄 것이며 불필요한 중복 로직의 개발을 막을 수도 있다.



