# 객체지향 프로그래밍(OOP,Object Oriented Programming)
- 객체 : 사물과 같이 유형적인 것과 개념이나 논리와 같은 무형적인 것들
- 지향 : 작정하거나 지정한 방향으로 나아감
- 객체 모델링: 현실세계의 객체를 SW 객체로 설계하는 것
# 객체지향 프로그래밍 특징 (A PIE)
- Abstraction(추상화)
- Polymorphism(다형성)
- Inheritance(상속)
- Encapsulation(캡슐화)
# 클래스
- 관련 있는 변수와 함수를 묶어서 만든 사용자정의 <자료형>
- 모든 객체들의 생산처
- 클래스 == 객체를 생성하는 틀
- 프로그래밍이 쓰이는 목적을 생각하여 어떤 객체를 만들어야 하는지 결정한다.
- 클래스를 통해 생성된 객체를 인스턴스라고 한다.
- 객체들 사이에서 메시지를 주고 받도록 만들어 준다.
# 클래스 구성
- 속성(Attribute) - 필드
- 동작(Behavior) - 메소드
- 생성자(Constructor)
# 클래스 변수(class variable)
- 클래스 영역 선언(static 키워드)
- 생성시기: 클래스가 메모리에 올라 갔을 때
- 모든 인스턴스가 공유함
# 인스턴스 변수(Instance variable)
- 클래스 영역 선언
- 생성시기: 인스턴스가 생성되었을 때 (new)
- 인스턴스 별로 생성됨.
# 지역 변수(local variable)
- 클래스 영역 이외(메서드,생성자...등)
- 생성시기 : 선언되었을 때
# 메소드(Method)
- 객체가 할 수 있는 행동을 정의
- 어떤 작업을 수행하는 명령문의의 집합에 이름을 붙여 놓은것
- 메소드의 이름은 소문자로 시작하는 것이 관례
# 메소드 선언
- 선언시 {} 안에 메소드가 해야 할 일을 정의
# 메소드 호출
- 호출한 메소드가 선언되어 있는 클래스를 접근한다.
- 클래스 객체.메소드 이름으로 호출
- static이 메소드에 선언되어 있을 때는 클래스 이름 메소드 이름으로 호출
# 매개변수(Parameter)
- 메소드에서 사용하는 것
# 인자(Argument)
- 호출하는 쪽에서 전달하는 것
# 매개변수 생략 가능
# 파라미터 전달 시 묵시적 형 변환
# 메소드
- 리턴 타입은 메소드를 선언할 때 지정, 없다면 void(return 문 생략 가능)
- 리턴 타입을 작성했다면 반드시 해당 타입의 값을 리턴
- 리턴 타입은 하나만 적용 가능
# 메소드 오버로딩(Overloading)
- 이름은 같고 매개변수가 다른 메소드를 여러 개 정의하는 것
- 중복 코드에 대한 효율적 관리 가능
- 파라미터의 개수 또는 순서, 타입이 달라야 할 것 (파라미터 이름만 다른 것은 X)
- 리턴 타입이 다른 것은 의미 X
# 클래스 : 관련 있는 변수와 함수를 묶어 만든 사용자 정의 자료형
# 객체: 하나의 역할을 수행하는 '메소드와 변수(데이터)'의 묶음
# 객체지향 프로그래밍 : 프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라, 프로그램을 수많은 '객체(object)'라는 기본 단위로 나누고 이들의 상호작용으로 서술하는 방식
# JVM 메모리 구조
- Java 언어는 메모리 관리를 개발자가 하지 않음
- GC(Garbage Collection)가 메모리 관리
# static 특징
1. 로딩 시점
- static : 클래스 로딩 시
- non-static : 객체 생성시
2. 메모리상의 차이
- static : 클래스당 하나의 메모리 공간만 할당
- non-static : 인스턴스 당 메모리가 별도로 할당
3. 문법적 특징
- static : 클래스 이름으로 접근
- non-static : 객체 생성 후 접근
4. static 영역에서는 non-static 영역을 직접 접근이 불가능
5. non-static 영역에서는 static 영역에 대한 접근이 가능
# 생성자
## 인스턴스가 생성될 때 최초 한번 수행되는 함수
- new 키워드와 함께 호출
- 클래스를 생성할 때 반드시 하나의 생성자 호출
- 성공적으로 실행되면 힙 영역에 객체 생성 후 객체의 번지가 리턴
- 필드의 초기화, 객체 생성 시 실행되어야 할 작업 작성
- PascalCase로 작성하는 것이 관례
## 클래스 명과 이름이 동일(대-소문자)
## 반환타입이 없다.(void 작성x)
# 기본(디폴트)생성자
- 클래스 내에 생성자가 하나도 정의되어 있지 않을 경우 JVM이 자동으로 제공하는 생성자
- 형태: 매개변수가 없는 형태, 클래스 명() {}
# 파라미터가 있는 생성자
- 생성자의 목적이 필드 초기화
- 생성자 호출 시 값을 넘겨주어야 함
- 해당 생성자를 작성하면 JVM에서 기본 생성자를 추가하지 않음
# 생성자 오버로딩을 지원한다
- 클래스 내에 메소드 이름이 같고 매개변수의 타입 또는 개수가 다른 것
# this
- 참조 변수로써 객체 자신을 가리킴
- this를 이용하여 자신의 멤버 접근 가능
- 지역변수와 필드의 이름이 동일할 경우 필드임을 식별할 수 있게 함
- 객체에 대한 참조 이므로 static 영역에서 this 사용 불가
# this의 활용
- this.맴버변수
- this([인자값..]): 생성자 호출
- this 생성자 호출 시 제한사항
- 생성자 내에서만 호출이 가능함
- 생성자 내에서 첫번째 구문에 위치해야 함
# 패키지
- PC의 많은 파일을 관리하기 위해서 폴더를 이용한다.
- 프로그램의 많은 클래스를 관리하기 위해서 패키지를 이용한다.
- 패키지는 클래스와 관련 있는 인터페이스들을 모아두기 위한 이름 공간
- 패키지의 구분은 .(dot) 연산자를 이용한다.
- 패키지의 이름은 시중에 나와 있는 패키지들과 구분되게 지어야 한다
- 일반적으로 소속이나 회사의 도메인을 사용한다.
# 임포트
- 다른 패키지에 있는 클래스를 사용하기 위해서는 import 과정이 필요한다.
- import를 선언할 때는 import 키워드 뒤에 package 이름고 ㅏ클래스 이름을 모두 입력하거나, 해당 패키지의 모든 클래스를 포함할 때는 '*'를 사용하기도 한다.
# 캡슐화
- 객체의 속성과 행위를 하나로 묶고
- 실제 구현 내용 일부를 외부에 감추어 은닉한다.
# 접근 제한자
- 클래스, 멤버 변수, 멤버 메서드 등의 선언부에서 접근 허용 범위를 지정하는 역할의 키워드 이다
- 접근 제한자 종류
1. public
2. protected
3. (default)
4. private
- 그 외 제한자
1. static : 클래스 레벨의 요소 설정
2. final : 요소를 더 이상 수정할 수 없게 함
3. abstract : 추상 메서드 및 추상 클래스 작성
- public : 모든 위치에서 접근이 가능
- protected : 같은 패키지에서 접근이 가능, 다른 패키지 접근 불가능 단, 다른 패키지의 클래스와 상속관계가 있을 경우 접근 가능
- default : 같은 패키지에서만 접근이 허용 접근제한자가 선언이 안 되었을 경우 기본 적용
- private: 자신 클래스에서만 접근이 허용
- 클래스 사용가능:public, default
- 내부클래스,멤버변수,메소드 사용가능: 4가지 모두 가능
# 상속
1. 확장성, 재 사용성
- 부모의 생성자와 초기화 블록은 상속 x
2. 클래스 선언 시 extends 키워드를 명시
- 자바는 다중 상속 허용X,단일 상속 지원
3. 관계
- 부모(상위,Super)클래스 : Person
- 자식(하위,Sub)클래스 : Student
4. 자식 클래스는 부모 클래스의 멤버변수, 메소드를 자신의 것처럼 사용할 수 있다.
(단, 접근 제한자에 따라 사용 여부가 달라진다.)
5. Object클래스는 모든 클래스의 조상 클래스
- 별도의 extends 선언이 없는 클래스는 extends Object가 생략
6. super 키워드
- super를 통해 조상 클래스의 생성자 호출